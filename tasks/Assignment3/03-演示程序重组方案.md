# Assignment3 演示程序重组方案

## 一、问题分析

### 1.1 原有冲突

在原始设计中存在以下冲突：

1. **Assignment 1-2 的设计**：
   - `Demo.java` 和 `PerformanceAnalysis.java` 位于 `src/main/java/` 根目录
   - 适合单一Assignment的项目结构

2. **Assignment 3 的设计**：
   - 在 `src/main/java/` 下规划了 `performance/` 包作为性能测试模块
   - 但没有明确演示程序的位置
   - 与Assignment 1-2 的演示程序产生组织上的混淆

### 1.2 冲突影响

- 不同Assignment的演示程序混在一起，难以区分
- 功能性代码（`performance/` 包）和演示代码位置不明确
- 项目结构随着Assignment增加会变得混乱

## 二、解决方案

### 2.1 新的目录结构

```
src/main/java/
├── core/                          # 核心抽象类
├── datatype/                      # 数据类型实现
├── io/                            # 数据读取模块
├── query/                         # 查询模块
├── index/                         # 索引模块
│   ├── pivottable/                # Pivot Table (Assignment 2)
│   └── tree/                      # 树索引 (Assignment 3)
│       ├── ghtree/
│       ├── vptree/
│       └── common/
├── performance/                   # 【性能测试框架】- Assignment 3
│   ├── PerformanceMetrics.java    # 性能指标数据结构
│   ├── PerformanceComparator.java # 性能对比工具
│   └── ExperimentRunner.java      # 实验运行框架
└── examples/                      # 【演示和分析程序】- 新增
    ├── assignment1_2/             # Assignment 1-2 演示程序
    │   ├── Demo.java              # 从根目录迁移
    │   └── PerformanceAnalysis.java # 从根目录迁移
    └── assignment3/               # Assignment 3 演示程序
        ├── TreeDemo.java          # 新建：GH树和VP树功能演示
        └── TreePerformanceAnalysis.java # 新建：树索引性能对比分析
```

### 2.2 设计原则

#### 2.2.1 模块分离原则

- **`performance/` 包**：可复用的性能测试框架
  - 提供通用的性能指标类
  - 提供性能对比工具
  - 提供实验执行框架
  - 可以被多个演示程序复用

- **`examples/` 包**：具体的演示和分析程序
  - 包含可运行的 `main` 方法
  - 调用 `performance/` 包中的工具
  - 按Assignment分类组织
  - 每个Assignment独立维护

#### 2.2.2 命名空间隔离原则

- 不同Assignment的演示程序使用不同的子包
- 避免类名冲突（如都可以有自己的 `Demo.java`）
- 便于独立运行和测试

#### 2.2.3 向后兼容原则

- 现有代码只需修改包声明和运行命令
- 不影响功能实现
- 平滑过渡

## 三、迁移步骤

### 3.1 创建新目录结构

```bash
# Windows PowerShell
New-Item -Path "src\main\java\examples\assignment1_2" -ItemType Directory -Force
New-Item -Path "src\main\java\examples\assignment3" -ItemType Directory -Force

# Linux/Mac
mkdir -p src/main/java/examples/assignment1_2
mkdir -p src/main/java/examples/assignment3
```

### 3.2 迁移现有文件

```bash
# Windows PowerShell
Move-Item -Path "src\main\java\Demo.java" -Destination "src\main\java\examples\assignment1_2\Demo.java"
Move-Item -Path "src\main\java\PerformanceAnalysis.java" -Destination "src\main\java\examples\assignment1_2\PerformanceAnalysis.java"

# Linux/Mac
mv src/main/java/Demo.java src/main/java/examples/assignment1_2/Demo.java
mv src/main/java/PerformanceAnalysis.java src/main/java/examples/assignment1_2/PerformanceAnalysis.java
```

### 3.3 修改包声明

#### 3.3.1 修改 `Demo.java`

在文件开头修改包声明：

```java
// 原来的声明（如果有）
// package 无或根包

// 修改为：
package examples.assignment1_2;
```

#### 3.3.2 修改 `PerformanceAnalysis.java`

在文件开头修改包声明：

```java
// 原来的声明（如果有）
// package 无或根包

// 修改为：
package examples.assignment1_2;
```

### 3.4 更新import语句（如果需要）

检查并确保import语句正确：

```java
// 核心类
import core.MetricSpaceData;
import core.MetricFunction;

// 数据类型
import datatype.vector.VectorData;
import datatype.vector.MinkowskiDistance;
import datatype.protein.ProteinData;
import datatype.protein.AlignmentDistance;

// IO模块
import io.VectorDataReader;
import io.ProteinDataReader;

// 查询模块
import query.*;

// 索引模块
import index.*;
import index.pivottable.*;
```

### 3.5 更新pom.xml（如果需要）

如果pom.xml中有指定mainClass，需要更新：

```xml
<!-- 原来的配置 -->
<mainClass>Demo</mainClass>

<!-- 修改为 -->
<mainClass>examples.assignment1_2.Demo</mainClass>
```

### 3.6 测试迁移结果

```bash
# 重新编译
mvn clean compile

# 测试运行
mvn exec:java "-Dexec.mainClass=examples.assignment1_2.Demo"
mvn exec:java "-Dexec.mainClass=examples.assignment1_2.PerformanceAnalysis"
```

## 四、Assignment 3 新增内容

### 4.1 创建 TreeDemo.java

**位置**: `src/main/java/examples/assignment3/TreeDemo.java`

**功能**:

- GH树构建和查询演示
- VP树构建和查询演示
- 树结构信息展示
- 查询结果对比

**基本结构**:

```java
package examples.assignment3;

import core.*;
import datatype.vector.*;
import io.*;
import index.tree.ghtree.*;
import index.tree.vptree.*;
import index.tree.common.*;
import java.util.List;

/**
 * Assignment 3 树索引演示程序
 */
public class TreeDemo {
    public static void main(String[] args) {
        System.out.println("=== Assignment 3: GH树和VP树演示 ===\n");
        
        // 1. 加载数据
        demonstrateDataLoading();
        
        // 2. GH树演示
        demonstrateGHTree();
        
        // 3. VP树演示
        demonstrateVPTree();
        
        // 4. 查询对比
        demonstrateQueryComparison();
    }
    
    private static void demonstrateDataLoading() {
        // TODO: 实现数据加载演示
    }
    
    private static void demonstrateGHTree() {
        // TODO: 实现GH树演示
    }
    
    private static void demonstrateVPTree() {
        // TODO: 实现VP树演示
    }
    
    private static void demonstrateQueryComparison() {
        // TODO: 实现查询对比
    }
}
```

### 4.2 创建 TreePerformanceAnalysis.java

**位置**: `src/main/java/examples/assignment3/TreePerformanceAnalysis.java`

**功能**:

- 构建时间对比（GH树 vs VP树）
- 查询性能对比（线性扫描 vs Pivot Table vs GH树 vs VP树）
- 不同参数影响分析（树高、叶子大小等）
- 生成实验报告

**基本结构**:

```java
package examples.assignment3;

import performance.*;
import core.*;
import datatype.vector.*;
import io.*;
import index.tree.ghtree.*;
import index.tree.vptree.*;
import index.pivottable.*;
import query.*;
import java.util.List;

/**
 * Assignment 3 树索引性能分析程序
 */
public class TreePerformanceAnalysis {
    public static void main(String[] args) {
        System.out.println("=== Assignment 3: 树索引性能分析 ===\n");
        
        // 1. 构建性能对比
        analyzeBuildPerformance();
        
        // 2. 范围查询性能对比
        analyzeRangeQueryPerformance();
        
        // 3. kNN查询性能对比
        analyzeKNNQueryPerformance();
        
        // 4. 参数影响分析
        analyzeParameterImpact();
        
        // 5. 生成报告
        generateReport();
    }
    
    private static void analyzeBuildPerformance() {
        // TODO: 使用 performance/ 包中的工具实现
    }
    
    private static void analyzeRangeQueryPerformance() {
        // TODO: 实现范围查询性能对比
    }
    
    private static void analyzeKNNQueryPerformance() {
        // TODO: 实现kNN查询性能对比
    }
    
    private static void analyzeParameterImpact() {
        // TODO: 实现参数影响分析
    }
    
    private static void generateReport() {
        // TODO: 生成实验报告
    }
}
```

## 五、运行命令更新

### 5.1 Assignment 1-2 演示程序

```bash
# Windows PowerShell
mvn exec:java "-Dexec.mainClass=examples.assignment1_2.Demo"
mvn exec:java "-Dexec.mainClass=examples.assignment1_2.PerformanceAnalysis"

# Linux/Mac
mvn exec:java -Dexec.mainClass=examples.assignment1_2.Demo
mvn exec:java -Dexec.mainClass=examples.assignment1_2.PerformanceAnalysis
```

### 5.2 Assignment 3 演示程序

```bash
# Windows PowerShell
mvn exec:java "-Dexec.mainClass=examples.assignment3.TreeDemo"
mvn exec:java "-Dexec.mainClass=examples.assignment3.TreePerformanceAnalysis"

# Linux/Mac
mvn exec:java -Dexec.mainClass=examples.assignment3.TreeDemo
mvn exec:java -Dexec.mainClass=examples.assignment3.TreePerformanceAnalysis
```

## 六、优势分析

### 6.1 清晰的组织结构

- 演示程序按Assignment分类，一目了然
- 功能性代码和演示代码分离
- 易于后续扩展（如Assignment 4、5等）

### 6.2 避免命名冲突

- 不同Assignment可以有同名的类（如 `Demo.java`）
- 使用包名进行隔离

### 6.3 代码复用

- `performance/` 包提供通用工具
- 各个演示程序可以复用性能测试框架
- 避免代码重复

### 6.4 易于维护

- 每个Assignment的演示程序独立
- 修改一个不影响其他
- 便于版本控制和协作开发

## 七、验证清单

迁移完成后，请检查以下项目：

- [ ] 新目录结构已创建
- [ ] 文件已正确迁移
- [ ] 包声明已更新
- [ ] import语句正确
- [ ] 编译无错误 (`mvn clean compile`)
- [ ] Assignment 1-2 的 Demo 可以正常运行
- [ ] Assignment 1-2 的 PerformanceAnalysis 可以正常运行
- [ ] README.md 已更新
- [ ] 架构规划文档已更新
- [ ] 所有测试通过 (`mvn test`)

## 八、注意事项

1. **Git版本控制**：
   - 迁移前建议创建新分支
   - 提交前确认所有功能正常
   - 使用 `git mv` 命令保留文件历史

2. **IDE配置**：
   - VSCode可能需要重新加载项目
   - 确保Java扩展正确识别新的包结构

3. **文档同步**：
   - 更新所有相关文档
   - 更新QUICKSTART.md中的运行命令

4. **向后兼容**：
   - 考虑添加Shell脚本/批处理文件简化运行命令
   - 可以保留旧的运行方式作为别名

## 九、后续工作

完成重组后，需要：

1. 实现Assignment 3的核心功能模块
2. 开发 `TreeDemo.java` 演示程序
3. 开发 `TreePerformanceAnalysis.java` 分析程序
4. 编写Assignment 3的测试用例
5. 撰写Assignment 3的实验报告

## 十、总结

本重组方案通过引入 `examples/` 包，解决了不同Assignment演示程序的组织问题，实现了：

- ✅ 清晰的目录结构
- ✅ Assignment之间的隔离
- ✅ 代码的可复用性
- ✅ 易于扩展和维护

这为后续Assignment的开发打下了良好的基础。
