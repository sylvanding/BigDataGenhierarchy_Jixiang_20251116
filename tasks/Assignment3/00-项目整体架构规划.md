# Assignment 3 项目整体架构规划

## 一、概述

本文档详细规划Assignment 3的项目架构，重点说明在Assignment 1和2的基础上，如何扩展系统以支持GH树和VP树两种树状索引结构。

## 二、整体架构设计原则

### 2.1 设计原则

1. **继承性**：充分复用Assignment 1和2的基础设施
2. **扩展性**：新增模块应易于扩展和维护
3. **统一性**：GHTree和VPTree应实现统一的接口
4. **可测试性**：每个模块都应便于单元测试
5. **清晰性**：代码结构清晰，职责分明

### 2.2 与之前Assignment的关系

```
Assignment 1 (基础设施)
    ├── 核心抽象类（MetricSpaceData, MetricFunction）
    ├── 数据类型（VectorData, ProteinData）
    ├── 距离函数（MinkowskiDistance, AlignmentDistance）
    └── 数据读取（DataReader及其实现）
              ↓
Assignment 2 (线性查询与Pivot Table)
    ├── 线性扫描查询（RangeQuery, KNNQuery, DKNNQuery）
    ├── Pivot Table索引
    └── Pivot选择算法（PivotSelection）
              ↓
Assignment 3 (树状索引) ← 本次任务
    ├── GH树索引（GHTree）
    ├── VP树索引（VPTree）
    ├── 树节点结构（TreeNode）
    ├── 树高控制（TreeHeightController）
    └── 性能对比框架（PerformanceComparator）
```

## 三、目录结构规划

### 3.1 完整目录结构

```
BigDataGenhierarchy_Jixiang_20251116/
├── src/
│   ├── main/
│   │   └── java/
│   │       ├── core/                          # 核心抽象类 (Assignment 1)
│   │       │   ├── MetricSpaceData.java       # 度量空间数据抽象父类
│   │       │   └── MetricFunction.java        # 距离函数抽象父类
│   │       ├── datatype/                      # 具体数据类型实现 (Assignment 1)
│   │       │   ├── vector/
│   │       │   │   ├── VectorData.java        # 向量数据类型
│   │       │   │   └── MinkowskiDistance.java # 闵可夫斯基距离
│   │       │   └── protein/
│   │       │       ├── ProteinData.java       # 蛋白质序列类型
│   │       │       └── AlignmentDistance.java # Alignment距离
│   │       ├── io/                            # 数据读取模块 (Assignment 1)
│   │       │   ├── DataReader.java            # 数据读取接口
│   │       │   ├── VectorDataReader.java      # 向量数据读取器
│   │       │   └── ProteinDataReader.java     # 蛋白质数据读取器
│   │       ├── query/                         # 查询模块 (Assignment 2)
│   │       │   ├── LinearScan.java            # 线性扫描查询
│   │       │   ├── RangeQuery.java            # 范围查询
│   │       │   ├── KNNQuery.java              # k近邻查询
│   │       │   └── DKNNQuery.java             # 多样化k近邻查询
│   │       ├── index/                         # 索引模块
│   │       │   ├── Index.java                 # 索引接口 (NEW)
│   │       │   ├── pivottable/                # Pivot Table索引 (Assignment 2)
│   │       │   │   ├── PivotTable.java        # Pivot Table实现
│   │       │   │   └── PivotSelection.java    # 支撑点选择算法
│   │       │   └── tree/                      # 树状索引 (Assignment 3 - NEW)
│   │       │       ├── TreeIndex.java         # 树状索引抽象基类
│   │       │       ├── TreeNode.java          # 树节点接口
│   │       │       ├── InternalNode.java      # 内部节点抽象类
│   │       │       ├── LeafNode.java          # 叶子节点类
│   │       │       ├── ghtree/                # GH树实现
│   │       │       │   ├── GHTree.java        # GH树主类
│   │       │       │   ├── GHInternalNode.java # GH树内部节点
│   │       │       │   ├── GHLeafNode.java    # GH树叶子节点
│   │       │       │   ├── GHTreeBuilder.java # GH树批建算法
│   │       │       │   ├── GHRangeQuery.java  # GH树范围查询
│   │       │       │   └── GHKNNQuery.java    # GH树kNN查询
│   │       │       ├── vptree/                # VP树实现
│   │       │       │   ├── VPTree.java        # VP树主类
│   │       │       │   ├── VPInternalNode.java # VP树内部节点
│   │       │       │   ├── VPLeafNode.java    # VP树叶子节点
│   │       │       │   ├── VPTreeBuilder.java # VP树批建算法
│   │       │       │   ├── VPRangeQuery.java  # VP树范围查询
│   │       │       │   └── VPKNNQuery.java    # VP树kNN查询
│   │       │       └── common/                # 树的公共组件
│   │       │           ├── TreeConfig.java    # 树配置类
│   │       │           ├── TreeHeightController.java # 树高控制器
│   │       │           └── PivotSelector.java # 统一的Pivot选择器
│   │       ├── performance/                   # 性能测试框架 (Assignment 3 - NEW)
│   │       │   ├── PerformanceMetrics.java    # 性能指标类
│   │       │   ├── PerformanceComparator.java # 性能对比器
│   │       │   └── ExperimentRunner.java      # 实验运行器
│   │       ├── examples/                      # 演示和分析程序 (NEW)
│   │       │   ├── assignment1_2/             # Assignment 1-2 演示程序
│   │       │   │   ├── Demo.java              # 基础功能演示（从根目录迁移）
│   │       │   │   └── PerformanceAnalysis.java # Pivot Table性能分析（从根目录迁移）
│   │       │   └── assignment3/               # Assignment 3 演示程序
│   │       │       ├── TreeDemo.java          # GH树和VP树功能演示
│   │       │       └── TreePerformanceAnalysis.java # 树索引性能对比分析
│   │       └── util/                          # 工具类
│   │           ├── Statistics.java            # 统计工具
│   │           └── Logger.java                # 日志工具
│   └── test/
│       └── java/
│           ├── datatype/                      # 数据类型测试 (Assignment 1)
│           │   ├── VectorDataTest.java
│           │   └── ProteinDataTest.java
│           ├── query/                         # 查询测试 (Assignment 2)
│           │   ├── RangeQueryTest.java
│           │   ├── KNNQueryTest.java
│           │   └── DKNNQueryTest.java
│           ├── index/                         # 索引测试
│           │   ├── PivotTableTest.java        # Pivot Table测试 (Assignment 2)
│           │   └── tree/                      # 树索引测试 (Assignment 3 - NEW)
│           │       ├── GHTreeTest.java        # GH树功能测试
│           │       ├── VPTreeTest.java        # VP树功能测试
│           │       ├── GHTreeCorrectnessTest.java  # GH树正确性测试
│           │       ├── VPTreeCorrectnessTest.java  # VP树正确性测试
│           │       └── TreeConsistencyTest.java    # 树间一致性测试
│           └── performance/                   # 性能测试 (TODO: 尚未实现)
│               ├── BuildPerformanceTest.java  # 构建性能测试
│               ├── QueryPerformanceTest.java  # 查询性能测试
│               └── ComparisonTest.java        # 对比测试
├── UMAD-Dataset/                              # 数据集目录
│   ├── examples/                              # 测试数据
│   │   ├── Protein/
│   │   │   └── test_proteins.fasta            # 测试用蛋白质数据
│   │   └── Vector/
│   │       └── test_vectors_2d.txt            # 测试用2维向量数据
│   └── full/                                  # 完整数据集
│       ├── Protein/
│       │   └── unzipped/
│       │       └── yeast.txt                  # 酵母蛋白质序列数据
│       └── Vector/
│           └── unzipped/
│               ├── clusteredvector-2d-100k-100c.txt  # 2维聚类向量
│               ├── hawaii.txt                 # 夏威夷边界数据
│               ├── randomvector-5-1m.txt      # 5维随机向量
│               ├── texas.txt                  # 德克萨斯边界数据
│               └── uniformvector-20dim-1m.txt # 20维均匀向量
├── Assignment1/
│   ├── Assignment1-Requirements.md
│   └── lab-report-1/                          # Assignment 1 实验报告
│       └── main.tex
├── Assignment2/
│   ├── Assignment2-Requirements.md
│   └── lab-report-2/                          # Assignment 2 实验报告
│       └── main.tex
├── Assignment3/                               # Assignment 3 目录 (NEW)
│   ├── Assignment3-Requirements.md
│   └── lab-report-3/                          # Assignment 3 实验报告 (NEW)
│       ├── main.tex
│       ├── chapters/
│       │   ├── 01-introduction.tex
│       │   ├── 02-theory.tex
│       │   ├── 03-implementation.tex
│       │   ├── 04-correctness.tex
│       │   ├── 05-experiments.tex
│       │   ├── 06-analysis.tex
│       │   └── 07-conclusion.tex
│       ├── figures/                           # 图表目录
│       └── tables/                            # 表格目录
├── docs/                                      # 文档目录（已存在）
├── tasks/                                     # 任务计划目录
│   ├── Assignment1-2/                         # Assignment 1&2 任务计划
│   │   ├── 00-项目整体架构规划.md
│   │   ├── 01-Assignment1-详细任务分解.md
│   │   ├── 02-Assignment2-详细任务分解.md
│   │   ├── 03-理论基础整理.md
│   │   └── README.md
│   └── Assignment3/                           # Assignment 3 任务计划 (NEW)
│       ├── 00-项目整体架构规划.md
│       ├── 01-Assignment3-详细任务分解.md
│       ├── 02-理论基础整理.md
│       └── README.md
└── pom.xml                                    # Maven配置文件
```

## 四、演示和分析程序组织

### 4.1 演示程序目录结构说明

为了清晰地区分不同Assignment的演示和性能分析程序，我们创建了 `examples/` 包来统一管理：

#### 4.1.1 Assignment 1-2 演示程序

**位置**: `src/main/java/examples/assignment1_2/`

包含以下文件（从根目录迁移）：

1. **Demo.java** - 基础功能演示
   - 向量数据类型演示
   - 蛋白质序列类型演示
   - 距离函数计算演示
   - 线性扫描查询演示
   - Pivot Table索引演示

2. **PerformanceAnalysis.java** - Pivot Table性能分析
   - Pivot Table vs 线性扫描性能对比
   - 不同支撑点选择策略对比
   - 不同数据集性能测试

**运行命令**:

```bash
mvn exec:java "-Dexec.mainClass=examples.assignment1_2.Demo"
mvn exec:java "-Dexec.mainClass=examples.assignment1_2.PerformanceAnalysis"
```

#### 4.1.2 Assignment 3 演示程序

**位置**: `src/main/java/examples/assignment3/`

包含以下新建文件：

1. **TreeDemo.java** - 树索引功能演示
   - GH树构建演示
   - VP树构建演示
   - 树索引范围查询演示
   - 树索引kNN查询演示
   - 树结构可视化展示

2. **TreePerformanceAnalysis.java** - 树索引性能对比分析
   - GH树 vs VP树 vs Pivot Table vs 线性扫描
   - 不同数据集的性能对比
   - 不同树高的影响分析
   - 构建时间和查询时间对比
   - 距离计算次数对比

**运行命令**:

```bash
mvn exec:java "-Dexec.mainClass=examples.assignment3.TreeDemo"
mvn exec:java "-Dexec.mainClass=examples.assignment3.TreePerformanceAnalysis"
```

#### 4.1.3 performance包 vs examples包的区别

- **performance/** 包：提供**可复用的性能测试框架**
  - `PerformanceMetrics.java`: 性能指标数据结构
  - `PerformanceComparator.java`: 通用的性能对比工具
  - `ExperimentRunner.java`: 实验执行框架
  - 这些类可以被多个程序复用

- **examples/** 包：提供**具体的演示和分析程序**
  - 调用 `performance/` 包中的工具类
  - 针对特定Assignment的实验设计
  - 包含具体的main方法，可直接运行

### 4.2 迁移计划

从当前结构迁移到新结构需要以下步骤：

1. **创建新目录**

   ```bash
   mkdir -p src/main/java/examples/assignment1_2
   mkdir -p src/main/java/examples/assignment3
   ```

2. **迁移现有文件**

   ```bash
   # 迁移Demo.java
   mv src/main/java/Demo.java src/main/java/examples/assignment1_2/Demo.java
   
   # 迁移PerformanceAnalysis.java
   mv src/main/java/PerformanceAnalysis.java src/main/java/examples/assignment1_2/PerformanceAnalysis.java
   ```

3. **修改包声明**
   - 将 `Demo.java` 中的包声明改为: `package examples.assignment1_2;`
   - 将 `PerformanceAnalysis.java` 中的包声明改为: `package examples.assignment1_2;`

4. **更新README.md**
   - 更新项目结构说明
   - 更新运行命令说明

5. **创建Assignment 3的演示程序**
   - 新建 `TreeDemo.java`
   - 新建 `TreePerformanceAnalysis.java`

## 五、核心模块详细设计

### 5.1 索引接口（Index.java）

这是所有索引结构的统一接口，确保不同索引可以互换使用。

```java
package index;

import core.MetricSpaceData;
import core.MetricFunction;
import query.RangeQuery;
import query.KNNQuery;
import java.util.List;

/**
 * 索引接口，所有索引结构都应实现此接口
 */
public interface Index {
    /**
     * 构建索引
     * @param dataset 数据集
     * @param metric 距离函数
     */
    void buildIndex(List<? extends MetricSpaceData> dataset, MetricFunction metric);
    
    /**
     * 范围查询
     * @param queryObject 查询对象
     * @param radius 查询半径
     * @return 查询结果列表
     */
    List<MetricSpaceData> rangeQuery(MetricSpaceData queryObject, double radius);
    
    /**
     * k近邻查询
     * @param queryObject 查询对象
     * @param k 近邻数量
     * @return 查询结果列表（按距离排序）
     */
    List<MetricSpaceData> knnQuery(MetricSpaceData queryObject, int k);
    
    /**
     * 获取索引统计信息
     * @return 统计信息字符串
     */
    String getStatistics();
    
    /**
     * 获取索引名称
     * @return 索引名称
     */
    String getIndexName();
}
```

### 5.2 树状索引抽象基类（TreeIndex.java）

GHTree和VPTree的共同父类，包含树的公共逻辑。

```java
package index.tree;

import core.MetricSpaceData;
import core.MetricFunction;
import index.Index;
import index.tree.common.TreeConfig;
import java.util.List;

/**
 * 树状索引抽象基类
 * 包含树的公共属性和方法
 */
public abstract class TreeIndex implements Index {
    // 根节点
    protected TreeNode root;
    
    // 树配置
    protected TreeConfig config;
    
    // 距离函数
    protected MetricFunction metric;
    
    // 原始数据集
    protected List<? extends MetricSpaceData> dataset;
    
    // 统计信息
    protected int distanceComputations = 0;
    protected int nodeAccesses = 0;
    protected int treeHeight = 0;
    protected int totalNodes = 0;
    protected int leafNodes = 0;
    
    /**
     * 构造函数
     * @param config 树配置
     */
    public TreeIndex(TreeConfig config) {
        this.config = config;
    }
    
    /**
     * 构建索引（模板方法）
     */
    @Override
    public void buildIndex(List<? extends MetricSpaceData> dataset, MetricFunction metric) {
        this.dataset = dataset;
        this.metric = metric;
        
        // 验证数据集
        validateDataset(dataset);
        
        // 选择pivot
        List<MetricSpaceData> pivots = selectPivots(dataset);
        
        // 递归构建树
        this.root = buildTree(dataset, pivots, 0);
        
        // 计算统计信息
        calculateStatistics();
    }
    
    /**
     * 选择pivot（子类实现）
     */
    protected abstract List<MetricSpaceData> selectPivots(List<? extends MetricSpaceData> dataset);
    
    /**
     * 递归构建树（子类实现）
     * @param data 当前节点的数据
     * @param pivots pivot点列表
     * @param depth 当前深度
     * @return 构建的节点
     */
    protected abstract TreeNode buildTree(List<? extends MetricSpaceData> data, 
                                          List<MetricSpaceData> pivots, 
                                          int depth);
    
    /**
     * 验证数据集
     */
    protected void validateDataset(List<? extends MetricSpaceData> dataset) {
        if (dataset == null || dataset.isEmpty()) {
            throw new IllegalArgumentException("数据集不能为空");
        }
    }
    
    /**
     * 计算统计信息
     */
    protected void calculateStatistics() {
        if (root != null) {
            treeHeight = calculateHeight(root);
            totalNodes = countNodes(root);
            leafNodes = countLeafNodes(root);
        }
    }
    
    // 辅助方法
    protected int calculateHeight(TreeNode node) {
        if (node == null || node instanceof LeafNode) {
            return 0;
        }
        InternalNode internal = (InternalNode) node;
        int maxChildHeight = 0;
        for (TreeNode child : internal.getChildren()) {
            maxChildHeight = Math.max(maxChildHeight, calculateHeight(child));
        }
        return 1 + maxChildHeight;
    }
    
    protected int countNodes(TreeNode node) {
        if (node == null) return 0;
        if (node instanceof LeafNode) return 1;
        InternalNode internal = (InternalNode) node;
        int count = 1;
        for (TreeNode child : internal.getChildren()) {
            count += countNodes(child);
        }
        return count;
    }
    
    protected int countLeafNodes(TreeNode node) {
        if (node == null) return 0;
        if (node instanceof LeafNode) return 1;
        InternalNode internal = (InternalNode) node;
        int count = 0;
        for (TreeNode child : internal.getChildren()) {
            count += countLeafNodes(child);
        }
        return count;
    }
    
    @Override
    public String getStatistics() {
        StringBuilder sb = new StringBuilder();
        sb.append("索引类型: ").append(getIndexName()).append("\n");
        sb.append("数据集大小: ").append(dataset.size()).append("\n");
        sb.append("树高度: ").append(treeHeight).append("\n");
        sb.append("总节点数: ").append(totalNodes).append("\n");
        sb.append("叶子节点数: ").append(leafNodes).append("\n");
        sb.append("距离计算次数: ").append(distanceComputations).append("\n");
        sb.append("节点访问次数: ").append(nodeAccesses).append("\n");
        return sb.toString();
    }
}
```

### 5.3 树节点结构

#### 5.3.1 树节点接口（TreeNode.java）

```java
package index.tree;

/**
 * 树节点接口
 * 所有树节点（内部节点和叶子节点）都应实现此接口
 */
public interface TreeNode {
    /**
     * 判断是否为叶子节点
     * @return true表示叶子节点，false表示内部节点
     */
    boolean isLeaf();
    
    /**
     * 获取节点中数据的数量
     * @return 数据数量
     */
    int size();
}
```

#### 5.3.2 内部节点抽象类（InternalNode.java）

```java
package index.tree;

import core.MetricSpaceData;
import java.util.List;

/**
 * 内部节点抽象类
 * 包含子节点和pivot信息
 */
public abstract class InternalNode implements TreeNode {
    // Pivot点列表
    protected List<MetricSpaceData> pivots;
    
    // 子节点列表
    protected List<TreeNode> children;
    
    // 节点深度
    protected int depth;
    
    @Override
    public boolean isLeaf() {
        return false;
    }
    
    @Override
    public int size() {
        int total = 0;
        for (TreeNode child : children) {
            total += child.size();
        }
        return total;
    }
    
    /**
     * 获取pivot列表
     */
    public List<MetricSpaceData> getPivots() {
        return pivots;
    }
    
    /**
     * 获取子节点列表
     */
    public List<TreeNode> getChildren() {
        return children;
    }
    
    /**
     * 获取节点深度
     */
    public int getDepth() {
        return depth;
    }
    
    /**
     * 判断查询是否需要访问某个子节点（子类实现）
     * @param childIndex 子节点索引
     * @param queryObject 查询对象
     * @param radius 查询半径
     * @return true表示需要访问，false表示可以剪枝
     */
    public abstract boolean shouldVisitChild(int childIndex, 
                                            MetricSpaceData queryObject, 
                                            double radius);
}
```

#### 5.3.3 叶子节点类（LeafNode.java）

```java
package index.tree;

import core.MetricSpaceData;
import java.util.ArrayList;
import java.util.List;

/**
 * 叶子节点类
 * 存储实际的数据对象
 */
public class LeafNode implements TreeNode {
    // 存储的数据对象列表
    private List<MetricSpaceData> data;
    
    // 节点深度
    private int depth;
    
    /**
     * 构造函数
     * @param data 数据列表
     * @param depth 节点深度
     */
    public LeafNode(List<? extends MetricSpaceData> data, int depth) {
        this.data = new ArrayList<>(data);
        this.depth = depth;
    }
    
    @Override
    public boolean isLeaf() {
        return true;
    }
    
    @Override
    public int size() {
        return data.size();
    }
    
    /**
     * 获取数据列表
     */
    public List<MetricSpaceData> getData() {
        return data;
    }
    
    /**
     * 获取节点深度
     */
    public int getDepth() {
        return depth;
    }
}
```

### 5.4 树配置类（TreeConfig.java）

```java
package index.tree.common;

/**
 * 树配置类
 * 统一管理树的各种参数
 */
public class TreeConfig {
    // 最大叶子节点容量
    private int maxLeafSize;
    
    // 目标树高（至少）
    private int minTreeHeight;
    
    // Pivot选择策略
    private PivotSelectionStrategy pivotStrategy;
    
    // 数据划分策略
    private PartitionStrategy partitionStrategy;
    
    // 是否强制平衡树
    private boolean forceBalance;
    
    /**
     * 默认构造函数
     */
    public TreeConfig() {
        this.maxLeafSize = 50;              // 默认最大叶子容量50
        this.minTreeHeight = 3;              // 默认最小树高3
        this.pivotStrategy = PivotSelectionStrategy.RANDOM;
        this.partitionStrategy = PartitionStrategy.BALANCED;
        this.forceBalance = false;
    }
    
    // Getters and Setters...
    
    public int getMaxLeafSize() { return maxLeafSize; }
    public void setMaxLeafSize(int maxLeafSize) { this.maxLeafSize = maxLeafSize; }
    
    public int getMinTreeHeight() { return minTreeHeight; }
    public void setMinTreeHeight(int minTreeHeight) { this.minTreeHeight = minTreeHeight; }
    
    public PivotSelectionStrategy getPivotStrategy() { return pivotStrategy; }
    public void setPivotStrategy(PivotSelectionStrategy strategy) { this.pivotStrategy = strategy; }
    
    public PartitionStrategy getPartitionStrategy() { return partitionStrategy; }
    public void setPartitionStrategy(PartitionStrategy strategy) { this.partitionStrategy = strategy; }
    
    public boolean isForceBalance() { return forceBalance; }
    public void setForceBalance(boolean forceBalance) { this.forceBalance = forceBalance; }
    
    /**
     * Pivot选择策略枚举
     */
    public enum PivotSelectionStrategy {
        RANDOM,         // 随机选择
        FFT,            // 最远优先遍历
        INCREMENTAL,    // 增量选择
        CLUSTER_CENTER  // 聚类中心
    }
    
    /**
     * 数据划分策略枚举
     */
    public enum PartitionStrategy {
        BALANCED,       // 平衡划分
        HYPERPLANE,     // 超平面划分
        SPHERE          // 球形划分
    }
}
```

### 5.5 树高控制器（TreeHeightController.java）

```java
package index.tree.common;

import core.MetricSpaceData;
import java.util.List;

/**
 * 树高控制器
 * 确保树达到指定的最小高度
 */
public class TreeHeightController {
    private TreeConfig config;
    
    public TreeHeightController(TreeConfig config) {
        this.config = config;
    }
    
    /**
     * 计算给定数据集应该使用的最大叶子大小，以确保达到最小树高
     * @param datasetSize 数据集大小
     * @param minHeight 最小树高
     * @return 最大叶子大小
     */
    public int calculateMaxLeafSize(int datasetSize, int minHeight) {
        // 假设二叉树，每层节点数大约翻倍
        // 叶子节点数约为 datasetSize / maxLeafSize
        // 树高 h ≈ log2(datasetSize / maxLeafSize)
        // 要使 h >= minHeight，则 maxLeafSize <= datasetSize / 2^minHeight
        
        int maxLeaf = (int) (datasetSize / Math.pow(2, minHeight));
        
        // 确保至少为1，最多为配置的最大值
        maxLeaf = Math.max(1, Math.min(maxLeaf, config.getMaxLeafSize()));
        
        return maxLeaf;
    }
    
    /**
     * 判断当前深度是否可以创建叶子节点
     * @param currentDepth 当前深度
     * @param dataSize 当前节点的数据量
     * @return true表示可以创建叶子，false表示必须继续划分
     */
    public boolean canCreateLeaf(int currentDepth, int dataSize) {
        // 如果还没达到最小高度，且数据量足够大，必须继续划分
        if (currentDepth < config.getMinTreeHeight() && 
            dataSize > config.getMaxLeafSize()) {
            return false;
        }
        
        // 如果数据量小于等于最大叶子大小，可以创建叶子
        return dataSize <= config.getMaxLeafSize();
    }
    
    /**
     * 根据当前深度和剩余数据量，建议的划分数
     * @param currentDepth 当前深度
     * @param dataSize 数据量
     * @return 建议的划分数（2表示二叉划分）
     */
    public int suggestPartitionNumber(int currentDepth, int dataSize) {
        // 如果离最小高度还很远，可能需要更多划分
        int remainingLevels = config.getMinTreeHeight() - currentDepth;
        
        if (remainingLevels <= 0) {
            return 2; // 默认二叉划分
        }
        
        // 计算需要的最小扇出数
        double requiredFanout = Math.pow(
            (double) dataSize / config.getMaxLeafSize(), 
            1.0 / remainingLevels
        );
        
        // 返回2或更大的值（向上取整）
        return Math.max(2, (int) Math.ceil(requiredFanout));
    }
}
```

## 六、GH树特定设计

### 6.1 GH树内部节点（GHInternalNode.java）

```java
package index.tree.ghtree;

import core.MetricSpaceData;
import core.MetricFunction;
import index.tree.InternalNode;
import index.tree.TreeNode;
import java.util.List;

/**
 * GH树内部节点
 * 使用两个pivot点，通过超平面划分空间
 */
public class GHInternalNode extends InternalNode {
    // GH树固定使用2个pivot
    private MetricSpaceData pivot1;
    private MetricSpaceData pivot2;
    
    // 左子树（离pivot1近）和右子树（离pivot2近）
    private TreeNode leftChild;
    private TreeNode rightChild;
    
    /**
     * 构造函数
     * @param pivot1 第一个pivot
     * @param pivot2 第二个pivot
     * @param leftChild 左子树
     * @param rightChild 右子树
     * @param depth 节点深度
     */
    public GHInternalNode(MetricSpaceData pivot1, MetricSpaceData pivot2,
                          TreeNode leftChild, TreeNode rightChild, int depth) {
        this.pivot1 = pivot1;
        this.pivot2 = pivot2;
        this.leftChild = leftChild;
        this.rightChild = rightChild;
        this.depth = depth;
        
        // 初始化children列表
        this.children = List.of(leftChild, rightChild);
        this.pivots = List.of(pivot1, pivot2);
    }
    
    /**
     * 判断是否需要访问子节点
     * 基于GH树的剪枝规则：
     * - 如果d(q, p1) - d(q, p2) > 2r，则可以排除左子树
     * - 如果d(q, p2) - d(q, p1) > 2r，则可以排除右子树
     */
    @Override
    public boolean shouldVisitChild(int childIndex, 
                                   MetricSpaceData queryObject, 
                                   double radius) {
        // 此方法由GHRangeQuery调用，传入距离已经计算好
        // 实际剪枝逻辑在查询类中实现
        return true; // 默认返回true，具体剪枝在查询时处理
    }
    
    // Getters
    public MetricSpaceData getPivot1() { return pivot1; }
    public MetricSpaceData getPivot2() { return pivot2; }
    public TreeNode getLeftChild() { return leftChild; }
    public TreeNode getRightChild() { return rightChild; }
}
```

## 七、VP树特定设计

### 7.1 VP树内部节点（VPInternalNode.java）

```java
package index.tree.vptree;

import core.MetricSpaceData;
import core.MetricFunction;
import index.tree.InternalNode;
import index.tree.TreeNode;
import java.util.ArrayList;
import java.util.List;

/**
 * VP树内部节点
 * 使用一个或多个pivot点，通过球形划分空间
 */
public class VPInternalNode extends InternalNode {
    // 每个子树对应的距离范围 [lower, upper]
    private List<double[]> distanceRanges;
    
    /**
     * 构造函数
     * @param pivots pivot点列表
     * @param children 子节点列表
     * @param distanceRanges 每个子节点对应的距离范围
     * @param depth 节点深度
     */
    public VPInternalNode(List<MetricSpaceData> pivots,
                          List<TreeNode> children,
                          List<double[]> distanceRanges,
                          int depth) {
        this.pivots = new ArrayList<>(pivots);
        this.children = new ArrayList<>(children);
        this.distanceRanges = new ArrayList<>(distanceRanges);
        this.depth = depth;
    }
    
    /**
     * 判断是否需要访问子节点
     * 基于VP树的剪枝规则：
     * - 对于每个子区域[L, U]：
     *   - 如果d(q, p) + r < L，则可以排除该子树
     *   - 如果d(q, p) - r > U，则可以排除该子树
     */
    @Override
    public boolean shouldVisitChild(int childIndex, 
                                   MetricSpaceData queryObject, 
                                   double radius) {
        // 实际剪枝逻辑在查询类中实现，这里提供距离范围
        return true;
    }
    
    /**
     * 获取指定子节点的距离范围
     * @param childIndex 子节点索引
     * @return 距离范围 [lower, upper]
     */
    public double[] getDistanceRange(int childIndex) {
        return distanceRanges.get(childIndex);
    }
    
    /**
     * 获取所有距离范围
     */
    public List<double[]> getDistanceRanges() {
        return distanceRanges;
    }
}
```

## 八、性能对比框架设计

### 8.1 性能指标类（PerformanceMetrics.java）

```java
package performance;

/**
 * 性能指标类
 * 记录索引构建和查询的各项性能指标
 */
public class PerformanceMetrics {
    // 构建性能
    private long buildTime;              // 构建时间（毫秒）
    private long buildDistanceComputations; // 构建时的距离计算次数
    private int treeHeight;              // 树高度
    private int totalNodes;              // 总节点数
    private int leafNodes;               // 叶子节点数
    
    // 查询性能
    private long queryTime;              // 查询时间（毫秒）
    private long queryDistanceComputations; // 查询时的距离计算次数
    private int nodeAccesses;            // 节点访问次数
    private int resultSize;              // 结果集大小
    
    // 内存使用
    private long memoryUsage;            // 内存使用（字节）
    
    // Getters and Setters...
    // toString(), toCSV()等方法...
}
```

## 九、实现优先级

### 9.1 第一阶段：基础设施（优先级最高）

1. Index接口
2. TreeIndex抽象类
3. TreeNode、InternalNode、LeafNode
4. TreeConfig和TreeHeightController

### 9.2 第二阶段：GH树实现

1. GHInternalNode
2. GHTree
3. GHTreeBuilder
4. GHRangeQuery
5. GHKNNQuery

### 9.3 第三阶段：VP树实现

1. VPInternalNode
2. VPTree
3. VPTreeBuilder
4. VPRangeQuery
5. VPKNNQuery

### 9.4 第四阶段：测试和性能评估

1. 单元测试
2. 正确性测试
3. 性能测试框架
4. 对比实验

## 十、与UMAD-OriginalCode的对应关系

| 本项目类 | UMAD-OriginalCode对应类 | 说明 |
|---------|----------------------|------|
| TreeIndex | AbstractIndex | 树索引抽象基类 |
| GHTree | GHIndex | GH树实现 |
| VPTree | VPIndex | VP树实现 |
| GHInternalNode | GHInternalNode | GH树内部节点 |
| VPInternalNode | VPInternalNode | VP树内部节点 |
| GHTreeBuilder | GHIndex.buildTree() | GH树构建算法 |
| VPTreeBuilder | VPIndex.buildTree() | VP树构建算法 |
| GHRangeQuery | GHRangeCursor | GH树范围查询 |
| VPRangeQuery | VPRangeCursor | VP树范围查询 |
| PartitionMethod | algorithms.datapartition.* | 数据划分方法 |
| PivotSelector | algorithms.pivotselection.* | Pivot选择算法 |

## 十一、注意事项

1. **接口统一**：确保GHTree和VPTree都实现Index接口，便于性能对比
2. **Pivot复用**：实现统一的Pivot选择器，确保两种树使用相同的pivot
3. **树高控制**：通过TreeHeightController确保树高至少为3层
4. **性能监控**：在关键位置记录距离计算次数、节点访问次数等指标
5. **代码复用**：充分利用Assignment 1和2的代码，避免重复实现
6. **测试覆盖**：每个核心类都要有对应的单元测试
7. **文档完善**：类和方法都要有清晰的JavaDoc注释

## 十二、总结

本架构规划详细说明了Assignment 3的项目结构和核心模块设计。通过：

1. 统一的索引接口设计
2. 清晰的树节点结构层次
3. 模块化的功能划分
4. 完善的性能监控机制

确保能够高质量地完成GH树和VP树的实现，并进行科学的性能对比分析。
