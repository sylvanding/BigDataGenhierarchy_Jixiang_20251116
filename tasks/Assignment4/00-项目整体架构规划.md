# Assignment 4 项目整体架构规划

## 一、概述

本文档详细规划Assignment 4的项目架构，重点说明在Assignment 1-3的基础上，如何扩展系统以支持3-pivot MVPT、3-pivot CGHT和完全线性划分树三种新的索引结构。

## 二、整体架构设计原则

### 2.1 设计原则

1. **继承性**：充分复用Assignment 1-3的基础设施，特别是GHTree和VPTree的实现
2. **扩展性**：三种新索引应作为现有树索引的自然扩展
3. **统一性**：三种索引实现统一的Index接口，便于性能对比
4. **可比较性**：支持相同支撑点在不同索引间共享
5. **可测试性**：每个模块都应便于单元测试和性能测试

### 2.2 与之前Assignment的关系

```
Assignment 1 (基础设施)
    ├── 核心抽象类（MetricSpaceData, MetricFunction）
    ├── 数据类型（VectorData, ProteinData）
    ├── 距离函数（MinkowskiDistance, AlignmentDistance）
    └── 数据读取（DataReader及其实现）
              ↓
Assignment 2 (线性查询与Pivot Table)
    ├── 线性扫描查询（RangeQuery, KNNQuery）
    ├── Pivot Table索引
    └── Pivot选择算法（PivotSelection）
              ↓
Assignment 3 (二叉树状索引)
    ├── GH树索引（GHTree）- 2个pivot，超平面划分
    ├── VP树索引（VPTree）- 1个pivot，球形划分
    ├── 树节点结构（TreeNode, InternalNode, LeafNode）
    └── 树配置与控制（TreeConfig, TreeHeightController）
              ↓
Assignment 4 (多pivot树状索引) ← 本次任务
    ├── 3-pivot MVPT（球形嵌套划分）
    ├── 3-pivot CGHT（完全超平面划分）
    ├── 3-pivot 完全线性划分树（支撑点空间线性划分）
    └── 统一的多pivot选择器
```

## 三、目录结构规划

### 3.1 新增目录结构

```
BigDataGenhierarchy_Jixiang_20251116/
├── src/
│   ├── main/
│   │   └── java/
│   │       ├── core/                          # 核心抽象类 (Assignment 1)
│   │       ├── datatype/                      # 具体数据类型实现 (Assignment 1)
│   │       ├── io/                            # 数据读取模块 (Assignment 1)
│   │       ├── query/                         # 查询模块 (Assignment 2)
│   │       ├── index/                         # 索引模块
│   │       │   ├── Index.java                 # 索引接口
│   │       │   ├── pivottable/                # Pivot Table索引 (Assignment 2)
│   │       │   └── tree/                      # 树状索引
│   │       │       ├── TreeIndex.java         # 树状索引抽象基类
│   │       │       ├── TreeNode.java          # 树节点接口
│   │       │       ├── InternalNode.java      # 内部节点抽象类
│   │       │       ├── LeafNode.java          # 叶子节点类
│   │       │       ├── ghtree/                # GH树实现 (Assignment 3)
│   │       │       ├── vptree/                # VP树实现 (Assignment 3)
│   │       │       ├── mvptree/               # MVPT实现 (Assignment 4 - NEW)
│   │       │       │   ├── MVPTree.java       # MVPT主类
│   │       │       │   ├── MVPInternalNode.java # MVPT内部节点
│   │       │       │   ├── MVPTreeBuilder.java  # MVPT批建算法
│   │       │       │   └── MVPRangeQuery.java   # MVPT范围查询
│   │       │       ├── cght/                  # CGHT实现 (Assignment 4 - NEW)
│   │       │       │   ├── CGHTree.java       # CGHT主类
│   │       │       │   ├── CGHInternalNode.java # CGHT内部节点
│   │       │       │   ├── CGHTreeBuilder.java  # CGHT批建算法
│   │       │       │   └── CGHRangeQuery.java   # CGHT范围查询
│   │       │       ├── linearpartition/       # 完全线性划分 (Assignment 4 - NEW)
│   │       │       │   ├── LinearPartitionTree.java # 线性划分树主类
│   │       │       │   ├── LinearPartitionInternalNode.java # 内部节点
│   │       │       │   ├── LinearPartitionBuilder.java # 批建算法
│   │       │       │   └── LinearPartitionRangeQuery.java # 范围查询
│   │       │       └── common/                # 树的公共组件
│   │       │           ├── TreeConfig.java    # 树配置类
│   │       │           ├── TreeHeightController.java # 树高控制器
│   │       │           ├── PivotSelector.java # 统一的Pivot选择器
│   │       │           └── MultiPivotSelector.java # 多Pivot选择器 (NEW)
│   │       ├── performance/                   # 性能测试框架
│   │       ├── examples/                      # 演示和分析程序
│   │       │   ├── assignment1_2/             # Assignment 1-2 演示程序
│   │       │   ├── assignment3/               # Assignment 3 演示程序
│   │       │   └── assignment4/               # Assignment 4 演示程序 (NEW)
│   │       │       ├── MultiPivotTreeDemo.java    # 多pivot树功能演示
│   │       │       └── MultiPivotPerformanceAnalysis.java # 性能对比分析
│   │       └── util/                          # 工具类
│   └── test/
│       └── java/
│           ├── index/
│           │   └── tree/
│           │       ├── mvptree/               # MVPT测试 (Assignment 4 - NEW)
│           │       │   └── MVPTreeTest.java
│           │       ├── cght/                  # CGHT测试 (Assignment 4 - NEW)
│           │       │   └── CGHTreeTest.java
│           │       └── linearpartition/       # 线性划分测试 (Assignment 4 - NEW)
│           │           └── LinearPartitionTreeTest.java
│           └── performance/                   # 性能对比测试
│               └── MultiPivotComparisonTest.java  # 三种索引对比测试 (NEW)
├── Assignment4/
│   ├── Assignment4-Requirements.md
│   └── lab-report-4/                          # Assignment 4 实验报告 (NEW)
│       ├── main.tex
│       ├── chapters/
│       │   ├── 01-introduction.tex
│       │   ├── 02-theory.tex
│       │   ├── 03-implementation.tex
│       │   ├── 04-correctness.tex
│       │   ├── 05-theoretical-analysis.tex
│       │   ├── 06-experimental-analysis.tex
│       │   └── 07-conclusion.tex
│       ├── figures/
│       └── tables/
└── tasks/
    └── Assignment4/                           # Assignment 4 任务计划 (NEW)
        ├── 00-项目整体架构规划.md
        ├── 01-Assignment4-详细任务分解.md
        ├── 02-理论基础整理.md
        └── README.md
```

## 四、核心模块详细设计

### 4.1 索引接口复用

三种新索引都实现现有的`Index`接口：

```java
public interface Index {
    void buildIndex(List<? extends MetricSpaceData> dataset, MetricFunction metric);
    List<MetricSpaceData> rangeQuery(MetricSpaceData queryObject, double radius);
    List<MetricSpaceData> knnQuery(MetricSpaceData queryObject, int k);
    String getStatistics();
    String getIndexName();
}
```

### 4.2 多Pivot选择器（MultiPivotSelector.java）

```java
package index.tree.common;

import core.MetricSpaceData;
import core.MetricFunction;
import java.util.List;

/**
 * 多Pivot选择器
 * 为三种索引提供统一的pivot选择方法，确保公平对比
 */
public class MultiPivotSelector {
    
    public enum SelectionStrategy {
        RANDOM,         // 随机选择
        FFT,            // 最远优先遍历
        MAX_SPREAD,     // 最大分散度
        INCREMENTAL     // 增量选择
    }
    
    private SelectionStrategy strategy;
    private long randomSeed;
    
    public MultiPivotSelector(SelectionStrategy strategy) {
        this.strategy = strategy;
        this.randomSeed = System.currentTimeMillis();
    }
    
    public MultiPivotSelector(SelectionStrategy strategy, long randomSeed) {
        this.strategy = strategy;
        this.randomSeed = randomSeed;
    }
    
    /**
     * 选择k个pivot
     * @param data 数据集
     * @param metric 距离函数
     * @param k pivot数量
     * @return pivot列表
     */
    public List<MetricSpaceData> selectPivots(
            List<? extends MetricSpaceData> data,
            MetricFunction metric,
            int k) {
        switch (strategy) {
            case RANDOM:
                return randomSelect(data, k);
            case FFT:
                return fftSelect(data, metric, k);
            case MAX_SPREAD:
                return maxSpreadSelect(data, metric, k);
            case INCREMENTAL:
                return incrementalSelect(data, metric, k);
            default:
                return randomSelect(data, k);
        }
    }
    
    // 各策略的具体实现...
    private List<MetricSpaceData> randomSelect(...) { ... }
    private List<MetricSpaceData> fftSelect(...) { ... }
    private List<MetricSpaceData> maxSpreadSelect(...) { ... }
    private List<MetricSpaceData> incrementalSelect(...) { ... }
}
```

### 4.3 3-pivot MVPT设计

#### 4.3.1 MVPT内部节点（MVPInternalNode.java）

```java
package index.tree.mvptree;

import core.MetricSpaceData;
import index.tree.InternalNode;
import index.tree.TreeNode;
import java.util.List;

/**
 * MVPT内部节点
 * 使用3个pivot进行3层球形划分，产生2^3=8个子区域
 */
public class MVPInternalNode extends InternalNode {
    // 3个支撑点
    private MetricSpaceData[] pivots;      // pivots[0], pivots[1], pivots[2]
    
    // 8棵子树（按照二进制编码：000, 001, 010, 011, 100, 101, 110, 111）
    // 第i位表示第i个pivot的内/外：0=内球，1=外球
    private TreeNode[] children;           // 8个子节点
    
    // 划分半径（每层的中位数距离）
    private double[] splitRadius;          // splitRadius[i] for pivot i
    
    // 每棵子树到每个支撑点的距离范围
    private double[][] lowerBound;         // lowerBound[childIdx][pivotIdx]
    private double[][] upperBound;         // upperBound[childIdx][pivotIdx]
    
    /**
     * 获取子节点索引
     * @param distToPivot0 数据到pivot0的距离
     * @param distToPivot1 数据到pivot1的距离
     * @param distToPivot2 数据到pivot2的距离
     * @return 子节点索引（0-7）
     */
    public int getChildIndex(double distToPivot0, double distToPivot1, double distToPivot2) {
        int idx = 0;
        if (distToPivot0 > splitRadius[0]) idx |= 1;  // bit 0
        if (distToPivot1 > splitRadius[1]) idx |= 2;  // bit 1
        if (distToPivot2 > splitRadius[2]) idx |= 4;  // bit 2
        return idx;
    }
    
    /**
     * 判断是否需要访问某个子节点（范围查询剪枝）
     */
    public boolean shouldVisitChild(int childIdx, double[] distToQuery, double radius) {
        for (int p = 0; p < 3; p++) {
            double dq = distToQuery[p];
            double L = lowerBound[childIdx][p];
            double U = upperBound[childIdx][p];
            
            // 剪枝条件：查询球与子树距离范围不相交
            if (dq + radius < L || dq - radius > U) {
                return false;
            }
        }
        return true;
    }
    
    /**
     * 判断子节点是否完全包含在查询范围内（包含规则）
     */
    public boolean isChildFullyContained(int childIdx, double[] distToQuery, double radius) {
        for (int p = 0; p < 3; p++) {
            double dq = distToQuery[p];
            double U = upperBound[childIdx][p];
            
            // 若 d(q, p) + U <= r，则子树全部在查询范围内
            if (dq + U <= radius) {
                return true;
            }
        }
        return false;
    }
    
    // Getters...
}
```

#### 4.3.2 MVPT主类（MVPTree.java）

```java
package index.tree.mvptree;

import core.MetricSpaceData;
import core.MetricFunction;
import index.tree.TreeIndex;
import index.tree.TreeNode;
import index.tree.LeafNode;
import index.tree.common.TreeConfig;
import index.tree.common.MultiPivotSelector;
import java.util.List;
import java.util.ArrayList;

/**
 * 3-pivot MVP树
 * 使用3个支撑点进行嵌套球形划分
 */
public class MVPTree extends TreeIndex {
    
    private static final int NUM_PIVOTS = 3;
    private static final int NUM_CHILDREN = 8;  // 2^3
    
    private MultiPivotSelector pivotSelector;
    
    public MVPTree(TreeConfig config, MultiPivotSelector pivotSelector) {
        super(config);
        this.pivotSelector = pivotSelector;
    }
    
    @Override
    protected List<MetricSpaceData> selectPivots(List<? extends MetricSpaceData> dataset) {
        return pivotSelector.selectPivots(dataset, metric, NUM_PIVOTS);
    }
    
    @Override
    protected TreeNode buildTree(List<? extends MetricSpaceData> data,
                                 List<MetricSpaceData> pivots,
                                 int depth) {
        // 终止条件
        if (data.size() <= config.getMaxLeafSize()) {
            return new LeafNode(data, depth);
        }
        
        // 选择3个pivot
        List<MetricSpaceData> nodePivots = selectPivots(data);
        
        // 计算所有数据到3个pivot的距离
        double[][] distances = computeDistances(data, nodePivots);
        
        // 计算划分半径（各pivot的中位数距离）
        double[] splitRadius = computeSplitRadius(distances);
        
        // 将数据分配到8个子集
        List<List<MetricSpaceData>> partitions = partitionData(data, distances, splitRadius);
        
        // 计算每个子集的距离范围
        double[][] lowerBound = new double[NUM_CHILDREN][NUM_PIVOTS];
        double[][] upperBound = new double[NUM_CHILDREN][NUM_PIVOTS];
        computeBounds(partitions, nodePivots, lowerBound, upperBound);
        
        // 递归构建子树
        TreeNode[] children = new TreeNode[NUM_CHILDREN];
        for (int i = 0; i < NUM_CHILDREN; i++) {
            if (!partitions.get(i).isEmpty()) {
                children[i] = buildTree(partitions.get(i), nodePivots, depth + 1);
            }
        }
        
        return new MVPInternalNode(nodePivots, children, splitRadius, 
                                   lowerBound, upperBound, depth);
    }
    
    @Override
    public String getIndexName() {
        return "3-pivot MVPT";
    }
    
    // 辅助方法...
}
```

### 4.4 3-pivot CGHT设计

#### 4.4.1 CGHT内部节点（CGHInternalNode.java）

```java
package index.tree.cght;

import core.MetricSpaceData;
import index.tree.InternalNode;
import index.tree.TreeNode;
import java.util.List;

/**
 * CGHT内部节点
 * 使用3个pivot进行完全超平面划分
 * 
 * 划分策略：基于距离差值
 * delta12 = d(x, p1) - d(x, p2)
 * delta13 = d(x, p1) - d(x, p3)
 * delta23 = d(x, p2) - d(x, p3) = delta13 - delta12
 * 
 * 使用(delta12, delta13)的符号组合划分为4个主区域，
 * 然后可选择进一步细分为8个区域
 */
public class CGHInternalNode extends InternalNode {
    // 3个支撑点
    private MetricSpaceData pivot1;
    private MetricSpaceData pivot2;
    private MetricSpaceData pivot3;
    
    // 子树（根据划分策略，可能是4个或8个）
    private TreeNode[] children;
    
    // 每个子树的delta范围
    private double[][] delta12Range;  // [childIdx][0]=min, [childIdx][1]=max
    private double[][] delta13Range;  // [childIdx][0]=min, [childIdx][1]=max
    
    /**
     * 获取子节点索引（基于距离差符号的4路划分）
     */
    public int getChildIndex(double d1, double d2, double d3) {
        int idx = 0;
        if (d1 >= d2) idx |= 1;  // delta12 >= 0
        if (d1 >= d3) idx |= 2;  // delta13 >= 0
        return idx;  // 0-3
    }
    
    /**
     * 判断是否需要访问某个子节点
     * 基于GH树剪枝规则的扩展
     */
    public boolean shouldVisitChild(int childIdx, double d1, double d2, double d3, double r) {
        double delta12 = d1 - d2;
        double delta13 = d1 - d3;
        
        // 剪枝条件：
        // 若 delta12 - 2r > delta12Range[childIdx][1]，排除
        // 若 delta12 + 2r < delta12Range[childIdx][0]，排除
        // 类似地检查delta13
        
        double[] range12 = delta12Range[childIdx];
        double[] range13 = delta13Range[childIdx];
        
        if (delta12 - 2*r > range12[1] || delta12 + 2*r < range12[0]) {
            return false;
        }
        if (delta13 - 2*r > range13[1] || delta13 + 2*r < range13[0]) {
            return false;
        }
        
        return true;
    }
    
    // Getters...
}
```

### 4.5 完全线性划分树设计

#### 4.5.1 线性划分内部节点（LinearPartitionInternalNode.java）

```java
package index.tree.linearpartition;

import core.MetricSpaceData;
import index.tree.InternalNode;
import index.tree.TreeNode;
import java.util.List;

/**
 * 完全线性划分树内部节点
 * 在3维支撑点空间中使用线性超平面划分
 * 
 * 支撑点空间坐标：(d1, d2, d3) = (d(x,p1), d(x,p2), d(x,p3))
 * 
 * 划分方式：
 * - 按d1的中位数划分为2部分
 * - 按d2的中位数划分为2部分  
 * - 按d3的中位数划分为2部分
 * 总共2^3=8个子区域
 */
public class LinearPartitionInternalNode extends InternalNode {
    // 3个支撑点
    private MetricSpaceData[] pivots;
    
    // 8棵子树
    private TreeNode[] children;
    
    // 划分阈值
    private double[] splitThreshold;  // 每个维度的划分阈值
    
    // 每棵子树在每个维度的距离范围
    private double[][] lowerBound;    // [childIdx][dimIdx]
    private double[][] upperBound;    // [childIdx][dimIdx]
    
    /**
     * 获取子节点索引
     */
    public int getChildIndex(double d1, double d2, double d3) {
        int idx = 0;
        if (d1 > splitThreshold[0]) idx |= 1;
        if (d2 > splitThreshold[1]) idx |= 2;
        if (d3 > splitThreshold[2]) idx |= 4;
        return idx;
    }
    
    /**
     * 判断是否需要访问子节点
     * 在支撑点空间中，查询区域是一个以(dq1, dq2, dq3)为中心，半径r的球
     * 使用切比雪夫距离（L∞），查询区域是一个边长2r的立方体
     */
    public boolean shouldVisitChild(int childIdx, double[] dq, double radius) {
        for (int dim = 0; dim < 3; dim++) {
            double L = lowerBound[childIdx][dim];
            double U = upperBound[childIdx][dim];
            
            // 查询区域在该维度的范围是 [dq[dim] - r, dq[dim] + r]
            // 若不相交则可排除
            if (dq[dim] + radius < L || dq[dim] - radius > U) {
                return false;
            }
        }
        return true;
    }
    
    // Getters...
}
```

## 五、配置扩展

### 5.1 扩展TreeConfig

```java
package index.tree.common;

/**
 * 树配置类扩展
 * 支持多pivot索引的配置
 */
public class TreeConfig {
    // 原有配置
    private int maxLeafSize = 50;
    private int minTreeHeight = 2;
    private PivotSelectionStrategy pivotStrategy = PivotSelectionStrategy.FFT;
    
    // 新增配置 for Assignment 4
    private int numPivots = 3;                    // pivot数量
    private int numPartitionsPerPivot = 2;        // 每个pivot的划分数
    private PartitionMode partitionMode = PartitionMode.BALANCED;
    
    // 划分模式枚举
    public enum PartitionMode {
        BALANCED,           // 平衡划分（中位数）
        EQUAL_RANGE,        // 等距划分
        CLUSTERING          // 聚类划分
    }
    
    // Getters and Setters...
    
    /**
     * 计算总子区域数
     */
    public int getTotalPartitions() {
        return (int) Math.pow(numPartitionsPerPivot, numPivots);
    }
}
```

## 六、实现优先级

### 6.1 第一阶段：基础设施扩展

1. 扩展TreeConfig支持多pivot配置
2. 实现MultiPivotSelector
3. 设计统一的多pivot内部节点接口

### 6.2 第二阶段：3-pivot MVPT实现

1. MVPInternalNode
2. MVPTree
3. MVPTreeBuilder
4. MVPRangeQuery
5. 单元测试

### 6.3 第三阶段：3-pivot CGHT实现

1. CGHInternalNode
2. CGHTree
3. CGHTreeBuilder
4. CGHRangeQuery
5. 单元测试

### 6.4 第四阶段：完全线性划分树实现

1. LinearPartitionInternalNode
2. LinearPartitionTree
3. LinearPartitionBuilder
4. LinearPartitionRangeQuery
5. 单元测试

### 6.5 第五阶段：测试和性能对比

1. 正确性验证测试
2. 三种索引一致性测试
3. 性能对比测试
4. 实验结果分析

## 七、三种索引的核心区别

| 特性 | 3-pivot MVPT | 3-pivot CGHT | 完全线性划分 |
|------|--------------|--------------|--------------|
| 划分空间 | 度量空间 | 度量空间 | 支撑点空间 |
| 划分依据 | 距离值 d(x,p) | 距离差 d(x,p1)-d(x,p2) | 距离向量 (d1,d2,d3) |
| 划分边界形状 | 球面 | 超平面 | 线性超平面 |
| 子区域数 | 8 (=2^3) | 4或8 | 8 (=2^3) |
| 剪枝条件 | 距离范围 | 距离差范围 | 坐标范围 |
| 包含规则 | 有 | 无 | 有 |
| 继承自 | VPTree | GHTree | 新设计 |

## 八、演示程序设计

### 8.1 MultiPivotTreeDemo.java

```java
package examples.assignment4;

/**
 * 多pivot树索引功能演示
 * 1. 展示三种索引的构建过程
 * 2. 展示树结构和统计信息
 * 3. 演示范围查询过程
 * 4. 验证查询结果正确性
 */
public class MultiPivotTreeDemo {
    public static void main(String[] args) {
        // 1. 加载测试数据
        // 2. 使用相同的pivot选择器
        // 3. 构建三种索引
        // 4. 展示构建过程和树结构
        // 5. 执行范围查询并对比结果
    }
}
```

### 8.2 MultiPivotPerformanceAnalysis.java

```java
package examples.assignment4;

/**
 * 多pivot树索引性能对比分析
 * 1. 构建性能对比
 * 2. 范围查询性能对比（不同查询半径）
 * 3. 剪枝效率对比
 * 4. 输出性能报告
 */
public class MultiPivotPerformanceAnalysis {
    public static void main(String[] args) {
        // 1. 加载多个数据集
        // 2. 统一pivot选择
        // 3. 构建三种索引并记录性能
        // 4. 执行查询实验
        // 5. 生成对比报告
    }
}
```

## 九、测试策略

### 9.1 单元测试

每种索引需要测试：

- 构建正确性
- 范围查询正确性（与线性扫描对比）
- 边界情况处理
- 空数据集处理

### 9.2 一致性测试

- 三种索引在相同数据和查询下返回相同结果
- 与Assignment 3的GHTree/VPTree结果一致

### 9.3 性能测试

- 构建时间
- 查询时间
- 距离计算次数
- 内存使用

## 十、注意事项

1. **Pivot一致性**：确保三种索引使用相同的pivot选择策略和相同的随机种子
2. **公平对比**：使用相同的maxLeafSize和其他配置参数
3. **树高控制**：确保树高至少为2层
4. **代码复用**：尽量复用Assignment 3的代码
5. **性能监控**：记录距离计算次数、节点访问次数等关键指标
6. **文档完善**：代码需有清晰的注释

## 十一、总结

本架构规划详细说明了Assignment 4的项目结构和核心模块设计。通过：

1. 统一的多pivot选择机制
2. 清晰的三种索引结构设计
3. 模块化的功能划分
4. 完善的测试策略

确保能够高质量地完成三种多pivot索引的实现，并进行科学的理论和实验对比分析。

---

**文档版本**：v1.0  
**创建日期**：2026-01-11  
**维护者**：Jixiang Ding
