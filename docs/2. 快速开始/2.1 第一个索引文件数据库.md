# 2.1 第一个索引文件数据库

## 2.1.1 生成索引文件数据库

下面我们将通过简单的修改参数来生成我们自己的第一个索引文件。UMAD将所有的操作层层打包，最终向用户在`BuildVPIndex`中预留了`batchBulkLoad`函数作为生成自己的索引数据库的最简单的入口。通过该入口用户只需要设置简单的参数便可以生成自己的数据库索引文件。

首先我们在项目中新建自己的入口类`Main.java`：

```java
public class Main {

    public static void main(String[] args)
    {

        /*支撑点数目设定*/
        int pNum = 10;

        /*支撑点的扇出数*/
        int sf = 3;

        /*叶子节点内的最大孩子数*/
        int maxLeafSize = 100;

        /*该参数是在实验室创建多个索引数据库时使用的，initialSize是最小的索引数据库的大小，
         * finalSize是最大的索引数据库的大小，stepSize是每次步进值。例如，我们有一个十万的
         * 数据点集，分别设置initialSize=10000，finalSize=50000，stepSize=10000，则
         * 最终会生成5个数据库，大小分别是10000、20000、30000、40000、50000 */
        int initialSize = 10000;
        int finalSize = 10000;
        int stepSize = 10000;

        /**/
        int pathLength = 0;

        /*数据划分方法，可选值有(均改成大写）：
         * Balanced：所有的分区都有相似的大小，划分迅速，但是性能表现最差。
         * ClusteringKMeans：根据内在的集群划分数据，针对每个维度采用k-means算法。
         * ExcludedMiddle：
         * CGHT：完全超平面划分(设置CGHT时，需要将枚举类指向CLUSTERINGKMEANS，并将半径设置为-2)
         * GHT：超平面划分(设置GHT时，需要将枚举类指向CLUSTERINGKMEANS，并将半径设置为-1)*/
        String dpmName = "BALANCED";

        /*
         * 支撑点选择方法，可选值有：
         * FFT: 使用 Farthest-First-Traversal 选择数据的角落点。
         * CENTER: 选择内部簇的中心，一种类似于CLARA的方法。(未实现）
         * RANDOM: 首先随机选择pivots，但不保证性能。
         * PCA:
         * EPCAF:
         * incremental：
         * pcaonfft：
         */
        String psmName = "fft";

        /*
         * fragment length, only meaningful for sequences
         */
        int frag = 6;

        /*
         * 要加载的向量维度
         */
        int dim = 2;

        /*
         * 是否要使用桶
         */
        boolean bucket = false;

        /*
         * 此参数应该配合PartitionMethod使用，
         * 当划分算法选择“Balance”时，该参数无效；
         * 当划分算法选择ClusteringKMeans时，该参数设为-1，对应的是GHT算法，-2对应的是CGHT）
         */
        double maxR = 0.1;

        /*
         * 此参数只有支撑点选择算法采用incremental才需要设置，分别对应算法的参数A和参数N的值
         */
        int setA = 10000;
        int setN = 50;

        /*
         * 此参数只有支撑点选择算法采用pcaonfft才需要设置
         */
        int fftScale = 100;

        /*
         * 生成的索引文件前缀
         */
        String indexPrefix = "vpindex";

        /*
         * 构建索引的数据文件位置
         * 注意，如果是本项目的那两个测试图片数据的话就只需要指出文件夹就好了。
         */
        String fileName = "D:\\WorkSpace\\IDEA\\UMAD\\testdata\\vector\\2.txt";

        /*
         * 构建索引的数据类型，可选值有：
         * ms：Spectra
         * msms：SpectraWithPrecursorMass
         * dna：DNA
         * rna：RNA
         * protein：Peptide
         * vector：Vector
         * image：Image
         */
        String dataType = "vector";

        //选择静态或者动态建立索引算法 ，0代表动态算法，1代表静态算法
        int mode=0;

        /*
         * 设置成空字符串即可，
         */
        String forPrint = "";    //自行设定



        //直接用默认距离函数生成索引数据库文件
        BuildVPIndex.batchBulkLoad(fileName, indexPrefix, dataType, dim, frag, initialSize, finalSize, stepSize,
                maxLeafSize, pNum, sf, pathLength, psmName, maxR, dpmName,setA,setN,fftScale, bucket, mode, forPrint);
        }
}
```

除了用上面的代码片段直接生成以外，我们还可以自己控制数据所使用的距离函数，只需要在数据绑定`Table`的时候指定一个距离函数即可：

```java
         /**
         * 尝试自定义一些参数生成索引数据文件
         *
         * 创建数据库，要根据之前指定的数据类型创建指定类型的数据库,具体对应如下：
         * ms        SpectraTable
         * msms      SpectraWithPrecursorMassTable
         * dna       DNATable
         * rna       RNATable
         * protein   PeptideTable
         * vector    DoubleVectorTable
         * image     ImageTable
         */
        Table table = null;
        try {
            table = new DoubleVectorTable(fileName,indexPrefix,initialSize,2, new CountedMetric( LMetric.EuclideanDistanceMetric));
            
            table.buildVPIndex(psm, pNum, dpm, sf, maxLeafSize, pathLength, bucket,0, forPrint);

        } catch (IOException e) {
            e.printStackTrace();
        }
        }
```

## 2.1.2 搜索索引文件数据库

现在，我们针对上面生成的数据库进行查询。首先也是给出一个写好的查询的代码片段，只需要设定相应的参数即可完成查询操作：

```java
public class Main {
	public static void main(String[] args){
        /*
         *待搜索索引文件的名字
         */
        String indexName = "vpindex";

        /*
         * 要查询的目标值从哪里读入
         */
        String queryFileName = "D:\\WorkSpace\\IDEA\\UMAD\\testdata\\query\\2.txt";

        /*
         * 保持空就好
         */
        String forPrint = "";

        /*
         *firstQuery 待搜索文件的读入行数的偏移值，默认是0，代表从第0行开始读入搜索
         *lastQuery 待索索文件的截止读入行数的偏移值，默认为1，代表读入前1行，但不包括第1行
         */
        int firstQuery = 0;
        int lastQuery = 2;

        /*
         * 分别是查询的最小半径、最大半径和半径变化步长。要求所有值均大于0
         */
        double minRadius = 0.2;
        double maxRadius = 0.2;
        double step = 0.1;

        boolean verify = true;
        Level debug = Level.OFF;

        /*
         * frag 片段长度，仅仅对数据类型是{@link Sequence}设置时才有意义
         * dim 要加载的向量数据的维度，仅仅对数据类型是{@link DoubleVector}才有意义
         */
        int frag = 6;
        int dim = 2;

        /*
         * length of the path distance list
         */
        int pathLength = 0;

        /*
         * 输出的结果文件名字
         */
        String resultsFileName = "result2.txt";

        // load index from file
        Table dataTable = TableManager.getTableManager(indexName).getTable(indexName);
        Index index;
        if (dataTable != null)
            index = dataTable.getIndex();
        else
            throw new Error("index: " + indexName + " does not exist");

        Table queryTable = null;
        try
        {

            queryTable = new DoubleVectorTable(queryFileName, "", lastQuery, dim);

        }
        catch (IOException e1)
        {
            e1.printStackTrace();
        }

        try
        {

            QueryVPIndex evaluator = new QueryVPIndex(index, queryTable, minRadius, maxRadius, step, verify
                    , debug, pathLength, frag, resultsFileName, firstQuery, lastQuery, forPrint);

            evaluator.evaluate();
        }
        catch(IllegalArgumentException illegal)
        {
            System.out.println("创建类时遇到参数非法异常：" + illegal.getMessage().toString());
        }
    }
}
```

除了修改上面的代码片段完成搜索，并且生成结果文件外，我们还可以自己完成搜索的过程，这样可以更好的控制要进行的操作。例子如下：

```java
        Index index = TableManager.getTableManager("vpindex-10000").getTable("vpindex-10000").getIndex();
        Table queryTable = null;
        try {
            queryTable = new DoubleVectorTable("D:\\WorkSpace\\IDEA\\UMAD\\testdata\\query\\2.txt", "", 2, 2);
        } catch (IOException e) {
            e.printStackTrace();
        }
        List allQuery = queryTable.getData();
        RangeQuery q = new RangeQuery((IndexObject) allQuery.get(0), 0.1);
        VPRangeCursor cursor = (VPRangeCursor) index.search(q);
        while (cursor.hasNext()) {
            System.out.println(cursor.next().getObject());
        }
```

通过上面的例子，我们完成了从建立索引到查询的全过程，之后我们将会更加细化的讲解每一个类，给出更多的自定义操作的例子。