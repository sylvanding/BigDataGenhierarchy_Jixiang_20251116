**一、数据与使用该数据构建的索引的封装、管理——Table类和TableManager类的介绍**

&emsp;&emsp;本项目主要用于面向多种数据类型的基于距离的度量空间索引树的研究，不同类型的数据由其对应的Table子类进行封装，项目中已有的数据类型有向量数据（由DoubleVectorTable封装）、图片数据（由ImageTable封装）、DNA数据（由DNATable封装）、序列数据（由SequenceTable封装，序列数据又包含了DNA数据（由继承了SequenceTable的DNATable封装）、蛋白质数据（由继承了PeptideTable封装）、RNA数据（由继承了SequenceTable的RNATable封装））和谱数据（由SpectraTable封装），如果要对除此以外的数据类型进行索引的建立，那么需要新建对应数据类型的继承了Table的子类（命名规则为：数据类型+Table）。以下我们具体介绍Table类的构成及其与TableManager类的关系：

&emsp;&emsp;在Table类中，数据由变量data保存，读取数据由抽象方法loadData声明，不同数据类型的读取过程和参数不同，Table的子类需要对loadData方法进行相应的实现与重载。在数据读取时需要指定"路径+文件名.后缀"，该参数由变量sourceFileName指定。因同一份数据文件可能读取其不同数据量的数据，所以Table类中定义了dataSize记录需要读取的数据量。需要注意的是读取到的数据中会有重复的数据点，如果需要对重复的数据进行压缩，简单来讲就是数据列表中不同的值只保存一次，调用Table类中的compressData方法即可完成压缩，使用变量originalRowIDs保存数据在未压缩的原始数据列表中的下标。因本项目是基于距离的树状索引的构建，不同数据类型数据需要传入对应的距离函数，在Table类中，使用变量metric记录对应数据类型的距离函数。

```java
public abstract class Table implements Serializable
{
	transient List<? extends IndexObject> 	data;
	protected String 			sourceFileName;
	protected int    			dataSize;
	public int[]  				originalRowIDs;
	protected Metric 			metric;
	protected Index                       	index;
	protected String                      	tableManagerName;
	protected String                      	indexPrefix;
	private   int                         	tableLocation = -1;
	
	public abstract void loadData(BufferedReader reader, int size);
	protected void compressData()
	{
		...
	}
	public void buildVPIndex(...)
	{
		...
	}
	
	...
}
```

&emsp;&emsp;对于相同的数据，可以建立不同的索引，因此在Table类中不同的索引对应这不同的索引构建方法，构建索引的方法为名为build+索引类型简称+Index的方法（例如优势点树的建树方法名为buildVPIndex，超平面树的建树方法名为buildGHIndex，这两种索引的构建已经在本项目中实现），变量index用于保存建好的索引。

&emsp;&emsp;以上内容简单的梳理了Table类的结构，下面我们结合使用TableManager类的实例tableManager管理Table类的实例table的机制，介绍Table类中的变量tableManagerName、indexPrefix和tableLocation，以及TableManager类。首先我们需要知道的是，因构建索引的需求不同，会使得建立索引所使用的数据类型不同，数据量不同，索引类型不同，我们使用Table类对数据与使用该数据构建的索引进行封装，从而方便我们对这些不同的table进行管理。那么，对于多个table的管理是由TableManager类完成的。

&emsp;&emsp;一个TableManager类的对象tableManager可以管理多个table，在TableManager类中，我们会指定tableManager的名称，即通过TableManager类的变量indexPrefix指定。那么如何实现一对多的管理呢？TableManager类通过三个Hashtable类型的变量，即tableHashtable、tableAddress和oiomLocations，来实现一对多的管理，其中变量tableHashtable存放多个<table在当前tableManger中的位置，table>键值对，table在当前tableManger中的位置由Table类中的变量tableLocation给定。tableAddress存放多个<table封装的索引对象的名称，table在当前tableManger中的位置>键值对，table封装的索引对象的名称由Table类中的indexPrexfix给定。oiomLocations存放多个<table在当前tableManger中的位置，索引对象的I/O对象指针>。Table类中的变量tableManagerName为管理当前table的tableManager的名称。这样，table根据自己的变量tableManagerName可以知道自己当前是被哪个tableManager管理的，tableManager可以通过tableHashtable、tableAddress和oiomLocations对多个table进行管理。

```java
public class TableManager implements Serializable, AutoCloseable
{
    private static TableManager              	tableManager;
    private final String                     	indexPrefix;
    transient protected ObjectIOManager            	oiom;
    private int                        		count;
	
    transient private Hashtable<Integer, Table>  	tableHashtable;
    private final Hashtable<String, Integer> 	tableAddress;
    private final Hashtable<Integer, Long>   	oiomLocations;
	
    ...
	
}

```

&emsp;&emsp;这里，我们详细介绍TableManager类。在TableManager类中，该类声明了tableManager对象，其作用是避免重复建立相同的tableManager，在方法getTableManager中，该方法通过输入tableManager的名称获取tableManager，如果发现当前名称的tableManager已经存在于磁盘上，那么就直接从本地读出该对象赋值给变量tableManager，反之直接新建一个tableManager。变量oiom用于读写table，需要注意的是整个项目的读取由公开数据库mckoi完成，要求使用oiom对象进行读写的类都实现Serilizable接口或者Externalizable接口，Table类和TableManager都实现了Serilizable接口，在本项目中mckoi数据库被打包成jar包导入到本项目中。当一个新的table对象需要被当前的tableManager管理时，需要使用tableManager调用其方法getNextLocation方法，该方法会使其变量count加一，也就是说，当前的tableManager会顺序的给新来的table进行编号，然后tableManager会调用其方法putTable，将该编号赋值给table的变量tableLocation，该tableManager的名称会赋值给table的tableManagerName，并在tableHashtable和tableAddress进行记录，此时tableManager也获得了新的table的管理权限。随后table可以进行索引的构建，索引建好后，我们需要使用tableManager对象调用其方法close，该方法使用变量oiom将table写入到本地，并在oiomLocations中写入指向自己的指针和对应的table，实现了oiom对象和table的对应。最后，将tableManager对象写入到本地，关闭各种输入输出流，整个程序运行完毕，本地会产生三个文件，分别保存了tableManger、table和索引，索引文件将在后续章节介绍。保存tableManger的文件的文件名为”tableManger的变量indexPrefix“+“-db”的形式，保存table的文件的文件名为“table的变量indexPrefix”+“-umad”+“000”的形式。“000”是当数据很大时，底层会对数据进行切割，切割成多个数据文件，“000”是文件的编号。到此，Table类和TableManager类的介绍告一段落，下面给出小提示。

小提示1：
&emsp;&emsp;本项目主要用于面向多种数据类型的基于距离的度量空间索引树的研究，如果你要用到新的数据类型，需要创建对应的Table子类，并在子类按需实现、重载loadData方法。

**二、距离函数**

&emsp;&emsp;在第一章中，我们讲述了不同类型的数据是如何封装的，在处理完数据后，我们需要定义与数据类型相对应的距离函数。

&emsp;&emsp;本项目将各种距离函数抽象成Metric接口，所有的距离函数都是为了计算对象之间的距离，因此在该接口中仅有一个方法getDistance，该方法需要子类根据距离函数的特点进行实现。在本项目中，已经定义了常用的向量数据所使用的距离函数类LMetric（在该类中可以计算L1、L2和L无穷距离）。如需添加新的距离函数，需要实现Metric接口，实现getDistance方法。

&emsp;&emsp;此外，在项目中，我们定义了CountedMetric类用来封装距离函数，用于距离计算次数的计数。该类有两个变量baseMetric（Metric类型）和counter（int类型），baseMetric用来封装需要封装的距离函数实例，counter用于保存实际构建索引时的距离计算次数。

**三、索引树中节点的定义**

&emsp;&emsp;因为本项目主要研究基于距离的度量空间索引树，所以我们先对树状索引应有的结构进行描述和相关类的定义。树状索引由内部节点、叶子节点组成，我们将这两种节点抽象成Node类，因为基于距离的度量空间索引树是根据数据到支撑点的距离对数据进行划分从而递归建立的，因此在树的各类节点中都存放了支撑点，所以Node类定义了变量pivotSet，用于存放当前节点所使用的支撑点。此外，定义变量dataSize用于保存当前节点所覆盖的数据的大小。

```java
public abstract class Node implements Externalizable
{
    IndexObject[] 	pivotSet;
    int           	dataSize;
    ...
}
```

&emsp;&emsp;在Node类之后，我们对内部节点和叶子节点进行抽象，这是因为不同的索引其内部节点和叶子节点保存的信息可能是不一样的。内部节点的抽象类为InternalNode，因为内部节点需要保存其孩子节点的指针，因此使用变量childAddresses来保存。用户根据所建的索引对内部节点的需求定义InternalNode的子类，本项目中已经定义了Vp-tree的内部节点类VPInternalNode和GH-tree的内部节点类GHInternalNode。叶子节点的抽象类为LeafNode，在叶子节点中，我们需要保存数据，因此使用变量data来保存叶子节点中的数据。在叶子节点中，我们也选取了支撑点，并计算支撑点到叶子中各个数据的距离，即pivot table用于查询时的排除，因此本项目定义了LeafNode的子类PivotTable类，用于对pivot table的操作。在PivotTable类中定义了变量distance，用于保存支撑点到数据的距离。

```java
public abstract class InternalNode extends Node
{
    long[] childAddresses;
    ...
}
```

```java
public abstract class LeafNode extends Node
{
    IndexObject[] data;
    ...
}
```

```java
public class PivotTable extends LeafNode
{
    private double[][] distance;
    ...
}
```

**四、索引对象的定义**

&emsp;&emsp;在上一章中，我们介绍了所有索引树因有的结构，即内部节点、叶子节点和PivotTable，在本章节中我们讲述索引对象。

```java
public interface Index extends Serializable
{
    void buildTree();
    List<? extends IndexObject> getAllPoints();
    int size();
    Metric getMetric();
    Cursor search(Query query);
    ...
}
```

&emsp;&emsp;因为索引树的类型有很多，因此我们在本项目中将索引抽象为Index接口。在Index接口中主要有5个方法，其中buildTree方法用于树状索引的建立，getAllPoints方法用于获取当前索引中的所有对象，size方法用于返回构建当前索引所使用的数据量，getMetric方法用于获取建立当前索引所使用的距离函数，search方法用于对当前索引的搜索操作。树状索引所有的共性可以由这几个函数去完成。

&emsp;&emsp;AbstractIndex类继承了Index类，处于具体索引类（例如VpIndex，GHIndex）和Index类的中间，其作用是将具体索引类具有共性的方法抽象出来，避免相同的方法在多个具体的索引类中重复出现。在AbstractIndex类中主要完成的是建树的过程，即bulkLoad()函数。在本项目中，基于支撑点的树状索引的层次建树分为三种模式：局部选点建树、全局选点建树和混合选点建树，HierarchicalPivotSelectionMode枚举类定义了这三种建树模式的类型。

```java
public abstract class AbstractIndex implements Index
{
    transient protected static String          nodeFileNameExtension = "000";
    transient protected ObjectIOManager        oiom;
    transient protected Logger                 logger;
    HierarchicalPivotSelectionMode             hierarchicalPivotSelectionMode;
    protected long                             root;
    int                                        totalSize;
    int                                        maxLeafSize;
    Metric                                     metric;
    String                                     indexPrefix;
    int                                        numPivot;
    int                                        numPartitions;
    transient List<? extends IndexObject>      data;
    transient List<? extends IndexObject>      pivotCandidateSet = null;
    transient int                              pivotCandidateSetSize = Integer.MIN_VALUE;
    transient IndexObject[]                    specifyPivots = null;

    public long bulkLoad()
    {
	...
    }
    ...
}
```

&emsp;&emsp;本项目目前实现的索引类型为VPIndex和GHIndex，需要说明的是，GHIndex在使用全局选点建树模式时，除根节点外只能建一层树，因为全局选点在整个建树过程中仅选择一次支撑点，所以支撑点集合是固定的，那么对于超平面划分来讲，划分多少次的结果都是一样的。相同索引流派中的索引方法会有所不同，其之间的不同是因其选点方法和划分方法的不同而不同，选点方法和划分方法分别由java.algorithms.pivotselection包和java.algorithms.datapartition包下的类进行定义。以VPIndex为例，在该类中需要指定选点方法和划分方法。

```java
public class VPIndex extends AbstractIndex
{
    private final PivotSelectionMethod pivotSelectionMethod;
    private final PartitionMethod      partitionMethod;

    int[] pivotSelection(...)
    {
	...
    }

    PartitionResults partition(...)
    {
	...
    }
    ...
}
```

**五、搜索**

&emsp;&emsp;近邻查询有三种：范围查询、k近邻查询和受限k近邻查询，查询对象由Query类定义，其子类RangeQuery类、KNearestNeighborQuery类和KNNQuery类分别可实例化范围查询对象、k近邻查询对象和受限k近邻查询对象。

&emsp;&emsp;索引树的搜索过程由Cursor类封装，其子类为目前已实现的范围搜索类RangeCursor，再往下是具体的索引搜索，例如VPRangeCursor和GHRangeCursor。

ps: 树状索引建立和查询具体细节参照代码中的注释。

