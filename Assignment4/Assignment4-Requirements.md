# Assignment4-Requirements

## 一、任务概述

核心任务是实现和对比分析**三种使用3个pivot的度量空间树状索引结构**：

1. **3-pivot MVPT（多优势点树）**：VP树的扩展，使用3个支撑点进行球形划分
2. **3-pivot CGHT（完全广义超平面树）**：GH树的扩展，根据距离之和与距离之差进行多路划分
3. **3-pivot 完全线性划分树**：在支撑点空间中使用线性边界进行数据划分

这三种树都是对Assignment 3中GH树和VP树的扩展，核心区别在于**如何利用3个支撑点的信息进行数据划分**。

---

## 二、详细任务要求

### 任务1：实现三种索引结构（30分）

#### 1.1 共同要求

- **统一的支撑点选择算法**：三种索引必须使用**完全相同**的支撑点选择算法（如FFT、随机选择等），确保公平对比
- **统一的接口设计**：三种索引都需实现`Index`接口，支持批建和范围查询操作
- **代码展示**：在报告中展示核心数据结构、批建算法和范围查询算法的代码

#### 1.2 3-pivot MVPT 实现

**基本思想**：

- MVP树是VP树的扩展，使用k个支撑点（本次k=3），每个支撑点将数据划分为f个部分（本次f=2），总共产生$f^k = 2^3 = 8$个子区域
- 逐个支撑点进行球形划分，每次将当前所有子集再细分

**内部节点数据结构**：

```java
MVPTInternalNode {
    MetricSpaceData[] pivots;     // 3个支撑点
    TreeNode[] children;           // 8棵子树
    double[][] lowerBound;        // 每棵子树到每个支撑点的距离下界
    double[][] upperBound;        // 每棵子树到每个支撑点的距离上界
}
```

**批建算法要点**：

1. 选择3个支撑点：$p_1, p_2, p_3$
2. 按第1个支撑点距离的中位数划分为2个子集
3. 对每个子集，按第2个支撑点距离的中位数再划分为2个子集
4. 对每个子集，按第3个支撑点距离的中位数再划分为2个子集
5. 共得到8个子集，递归构建子树
6. 记录每棵子树到每个支撑点的距离范围$[L_i, U_i]$

**范围查询剪枝规则**：

- 对于查询(q, r)和子树i，计算$d_j = d(q, p_j)$，$j = 1,2,3$
- 若存在任意j使得$d_j + r < L_{i,j}$或$d_j - r > U_{i,j}$，则可排除子树i
- 若存在任意j使得$d_j + U_{i,j} \leq r$，则子树i的数据全部为查询结果

#### 1.3 3-pivot CGHT 实现

**基本思想**：

- 完全广义超平面树（Complete GHT）由毛睿教授于2014年提出
- 核心思想：**充分利用3个支撑点蕴含的所有距离信息**
- 对于2个支撑点$p_1, p_2$，可以定义两个变量：
  - 距离之和：$s = d(x, p_1) + d(x, p_2)$
  - 距离之差：$\delta = d(x, p_1) - d(x, p_2)$
- 基于$s$和$\delta$的不同取值范围进行多路划分

**3个支撑点的CGHT实现方案**：

选择3个支撑点$p_1, p_2, p_3$，定义：

- $d_1 = d(x, p_1)$, $d_2 = d(x, p_2)$, $d_3 = d(x, p_3)$

**方案A：两两配对划分**

- 使用$(p_1, p_2)$进行第一层划分（基于$d_1 - d_2$的符号，2路）
- 使用$(p_1, p_3)$进行第二层划分（基于$d_1 - d_3$的符号，2路）
- 使用$(p_2, p_3)$进行第三层划分（基于$d_2 - d_3$的符号，2路）
- 总共$2^3 = 8$个子区域

**方案B：距离差值多路划分（推荐）**

- 定义$\delta_{12} = d_1 - d_2$，$\delta_{13} = d_1 - d_3$，$\delta_{23} = d_2 - d_3$
- 基于$(\delta_{12}, \delta_{13})$的值划分为多个区域
- 注意：$\delta_{23} = \delta_{13} - \delta_{12}$，只需要2个独立变量

**内部节点数据结构**：

```java
CGHTInternalNode {
    MetricSpaceData[] pivots;     // 3个支撑点
    TreeNode[] children;           // 子树
    double[][] deltaRanges;        // 每棵子树的距离差范围
    int depth;
}
```

**范围查询剪枝规则**：

- 基于GH树剪枝规则的扩展
- 若$d(q, p_i) - d(q, p_j) > 2r$，则可排除$\delta_{ij}$值较小一侧的子树

#### 1.4 3-pivot 完全线性划分树实现

**基本思想**：

- 在支撑点空间（pivot space）中，数据被映射为$(d_1, d_2, d_3)$三维向量
- 使用**线性超平面**对支撑点空间进行划分
- 线性边界的形式：$a_1 d_1 + a_2 d_2 + a_3 d_3 = c$

**实现方案**：

- 使用3个支撑点将数据映射到3维支撑点空间
- 在3维空间中选择合适的线性划分超平面
- 划分方式可以是：
  - **正交划分**：分别按$d_1$、$d_2$、$d_3$的中位数划分
  - **对角划分**：按$d_1 + d_2 + d_3$的值划分
  - **混合划分**：结合以上方式

**内部节点数据结构**：

```java
LinearPartitionInternalNode {
    MetricSpaceData[] pivots;     // 3个支撑点
    TreeNode[] children;           // 子树
    double[][] hyperplanes;        // 划分超平面参数
    double[][] distanceRanges;     // 每棵子树的距离范围
}
```

**范围查询剪枝规则**：

- 查询对象在支撑点空间中的坐标为$(d_1, d_2, d_3)$
- 查询区域是一个以该点为中心、半径为r的球（在切比雪夫距离下）
- 若查询球与某子树区域不相交，则可排除该子树

---

### 任务2：正确性验证（10分）

#### 2.1 数据集要求

- 至少使用**2个不同的数据集**
- 建议的数据集类型：
  - 低维向量数据（2-4维）：如clusteredvector-2d或hawaii数据
  - 蛋白质序列数据：如yeast蛋白质序列（长度6）
  - 高维向量数据（可选）：如randomvector-5d

#### 2.2 树高要求

- 索引树高度**至少2层**（即至少有1层内部节点+叶子节点）
- 通过调整`maxLeafSize`参数控制树高
- 在报告中说明树高控制方法

#### 2.3 验证方法

- 与线性扫描结果对比，确保范围查询结果完全一致
- 展示小规模数据集上的构建过程和查询过程
- 可手工验证关键计算步骤

---

### 任务3：理论分析（30分）

从理论角度对比分析三种索引结构的区别和联系、优缺点。

#### 3.1 数据划分方式对比

| 方面 | 3-pivot MVPT | 3-pivot CGHT | 完全线性划分 |
|------|--------------|--------------|--------------|
| 划分方式 | 球形嵌套划分 | 超平面组合划分 | 线性超平面划分 |
| 划分空间 | 度量空间 | 度量空间 | 支撑点空间 |
| 利用的距离信息 | 距离值 | 距离差值 | 距离向量 |
| 子区域数量 | $f^k = 8$ | 取决于实现 | 取决于实现 |

#### 3.2 支撑点使用效率对比

- MVPT：每个支撑点独立进行球形划分，信息利用相对独立
- CGHT：利用支撑点间的距离差，信息利用更加联合
- 完全线性划分：在支撑点空间中统一利用所有距离信息

#### 3.3 剪枝能力理论分析

- 分析各索引的剪枝条件
- 讨论在什么情况下各索引的剪枝效果更好
- 讨论维度灾难对各索引的影响

#### 3.4 时空复杂度分析

- 构建时间复杂度
- 查询时间复杂度（平均/最坏）
- 空间复杂度

#### 3.5 优缺点总结

对每种索引结构总结其：

- 理论优势
- 理论局限
- 适用场景

---

### 任务4：实验分析（30分）

从实验角度对比分析三种索引结构。

#### 4.1 实验方案设计

**评价指标**：

- 构建时间（毫秒）
- 查询时间（毫秒）
- 距离计算次数（构建阶段/查询阶段）
- 节点访问次数
- 剪枝率：$1 - \frac{\text{访问的叶子节点数}}{\text{总叶子节点数}}$

**实验变量**：

- 数据集类型/规模
- 查询半径大小
- 树的配置参数（maxLeafSize等）

**控制变量**：

- 三种索引使用相同的支撑点
- 相同的叶子节点大小限制
- 相同的查询对象集合

#### 4.2 实验数据集

| 数据集 | 类型 | 维度 | 数据量 | 距离函数 |
|--------|------|------|--------|----------|
| 数据集1 | 低维向量 | 2-4维 | 1000+ | 欧几里得距离 |
| 数据集2 | 蛋白质序列 | 序列长度6 | 500+ | 编辑距离 |

#### 4.3 实验内容

1. **索引构建性能对比**
   - 构建时间
   - 构建阶段距离计算次数
   - 树的结构统计（节点数、树高、平衡性）

2. **范围查询性能对比**
   - 不同查询半径下的性能
   - 查询时间
   - 距离计算次数
   - 剪枝率

3. **数据分布影响分析**
   - 均匀分布数据 vs 聚类分布数据
   - 不同维度数据的表现

#### 4.4 结果分析

- 汇总实验结果
- 分析性能差异的原因
- 验证理论分析的预测
- 讨论各索引的适用场景

---

## 三、提交要求

### 3.1 实验报告

- 使用LaTeX编写
- 存放位置：`Assignment4/lab-report-4/`
- 报告结构建议：

```
1. 引言
   1.1 研究背景与意义
   1.2 任务回顾与目标
       1.2.1 前序工作简述
       1.2.2 本次任务目标
   1.3 报告结构

2. 理论基础
   2.1 度量空间与支撑点空间
   2.2 MVP树原理
   2.3 完全广义超平面树原理
   2.4 完全线性划分原理

3. 算法实现
   3.1 系统架构
   3.2 3-pivot MVPT实现
       3.2.1 数据结构
       3.2.2 批建算法
       3.2.3 范围查询算法
   3.3 3-pivot CGHT实现
       3.3.1 数据结构
       3.3.2 批建算法
       3.3.3 范围查询算法
   3.4 完全线性划分树实现
       3.4.1 数据结构
       3.4.2 批建算法
       3.4.3 范围查询算法
   3.5 统一的支撑点选择策略

4. 正确性验证
   4.1 测试数据集
   4.2 各索引正确性验证
   4.3 结果一致性验证

5. 理论对比分析
   5.1 数据划分方式对比
   5.2 支撑点使用效率对比
   5.3 剪枝能力分析
   5.4 时空复杂度分析
   5.5 优缺点总结

6. 实验对比分析
   6.1 实验方案设计
   6.2 实验环境
   6.3 索引构建性能对比
   6.4 范围查询性能对比
   6.5 结果分析与讨论

7. 总结与展望
```

### 3.2 代码

- 保持在`src/main/java/`目录下的现有结构
- 新增的索引类建议放在`index/tree/`目录下：
  - `mvptree/`：MVPT实现
  - `cght/`：CGHT实现
  - `linearpartition/`：完全线性划分实现

### 3.3 数据集

- 使用项目中已有的数据集
- 位置：`UMAD-Dataset/`目录

---

## 四、评分标准

| 任务 | 分值 | 评分要点 |
|------|------|----------|
| 任务1：实现 | 30分 | 代码正确性、完整性、代码质量、接口统一性 |
| 任务2：验证 | 10分 | 数据集选择合理、树高满足要求、验证方法正确 |
| 任务3：理论分析 | 30分 | 分析深入、对比全面、观点正确、论述清晰 |
| 任务4：实验分析 | 30分 | 方案合理、实验充分、分析到位、图表规范 |

---

## 五、参考资料

1. 课程教材《大数据泛构》相关章节：
   - 第3.5.3节：MVP树
   - 第3.4.3节：GH树的扩展（完全超平面树）
   - 第4章：支撑点空间模型
   - 第6章：数据划分

2. Assignment 3的实现作为基础

3. 参考论文：
   - Bozkaya T, Ozsoyoglu M. Indexing large metric spaces for similarity search queries[J]. ACM Transactions on Database Systems (TODS), 1999, 24(3): 361-404.
   - Mao R, Liu S, Xu H, et al. On data partitioning in tree structure metric-space indexes[C]//International Conference on Database Systems for Advanced Applications. Cham: Springer International Publishing, 2014: 141-155.
